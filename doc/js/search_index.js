var search_data = {"index":{"searchIndex":["cli","challenge","worker","workerexception","generate_dataset()","parseclioptions()","process()","validateandbuildrooms()","validatedepartment()","readme"],"longSearchIndex":["cli","challenge","worker","workerexception","challenge::generate_dataset()","cli::parseclioptions()","worker::process()","cli::validateandbuildrooms()","cli::validatedepartment()",""],"info":[["CLI","","CLI.html","","<p>The Command-Line Interface for processing the user&#39;s arguments.\n"],["Challenge","","Challenge.html","","<p>Helper module for the application\n"],["Worker","","Worker.html","","<p>Parse and process the input CSV file and generate the outputs.\n"],["WorkerException","","WorkerException.html","","<p>Raised when we have an invalid structure CSV\n"],["generate_dataset","Challenge","Challenge.html#method-c-generate_dataset","(filename, rows)","<p>Generate a sample dataset with randomized data.\n<p>Parameters :\n<p><p>filename &mdash; the file name to generate.\n"],["parseCLIOptions","CLI","CLI.html#method-c-parseCLIOptions","(args)","<p>Process CLI arguments.\n<p>Receive the parameter <code>args</code> and return the parsed arguments as\na <code>Hash</code> or <code>nil</code> (incorrect …\n"],["process","Worker","Worker.html#method-c-process","(filename, department, rooms, path)","<p>Read and check filename and write the relevant output files.\n<p>Receive the following parameters :\n<p><code>filename</code> …\n"],["validateAndBuildRooms","CLI","CLI.html#method-c-validateAndBuildRooms","(rooms)","<p>Check and get the room&#39;s full name to process.\n<p>This method always return at least one Room. If empty …\n"],["validateDepartment","CLI","CLI.html#method-c-validateDepartment","(department)","<p>Check the department filter.\n<p>Parameter :\n<p><p>department  &mdash; the department to filter.\n"],["README","","README_rdoc.html","","<p>README \n<p>Description\n<p>This is the Ruby version of the Challenge project. I implemented this\nversion to show …\n"]]}}